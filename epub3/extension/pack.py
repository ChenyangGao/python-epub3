#!/usr/bin/env python
# coding: utf-8

__author__  = "ChenyangGao <https://chenyanggao.github.io>"
__version__ = (0, 0, 1)
__all__ = ["pack", "pack_sphinx"]

if __name__ == "__main__":
    from argparse import ArgumentParser

    parser = ArgumentParser(description="Packing the HTMLs generated by Sphinx into ePub")
    parser.add_argument("source_directory", help="The source directory containing the files to be packaged.")
    parser.add_argument("-s", "--save-path", help="Path where the ePub file will be saved. If not provided, it will be "
                        "saved in the same directory as the source with the .epub extension.")
    parser.add_argument("-f", "--not-follow-symlinks", action="store_true", help="Do not follow any symbolic links.")
    parser.add_argument("--compress", action="store_true", help="Perform deflation compression.")
    args = parser.parse_args()

import os.path as ospath
import posixpath

from collections import deque
from datetime import datetime
from glob import iglob
from io import BytesIO
from os import fsdecode, listdir, remove, PathLike
from pathlib import Path
from typing import (
    Callable, Container, Iterator, Optional, Sequence, MutableSequence
)
from urllib.parse import urlsplit
from zipfile import ZIP_DEFLATED

from lxml.etree import tostring
from lxml.html import document_fromstring

__import__("sys").path.insert(0, str(Path(__file__).parents[2]))

from epub3 import ePub
from epub3.util.xml_plus import to_xhtml
from epub3.util.template import make_nav_xhtml


def oebps_iter(
    top: bytes | str | PathLike, 
    filter: Optional[Callable[[Path], bool]] = None, 
    follow_symlinks: bool = True, 
    on_error: None | bool | Callable = None, 
) -> Iterator[tuple[str, Path]]:
    """Iterate over the directory structure starting from `top` (exclusive), 
    yield a tuple of two paths each time, one is a relative path based on `top`, 
    the other is the corresponding actual path object (does not include a directory).

    Note: This function uses breadth-first search (bfs) to iterate over the directory structure.

    :param top: The directory path to start the iteration from.
    :param filter: A callable that takes a Path object as input and returns True 
                   if the path should be included, or False otherwise.
    :param follow_symlinks: If True, symbolic links will be followed during iteration.
    :param on_error: A callable to handle any error encountered during iteration.

    :yield: A tuple containing the href (a relative path based on `top`) and the corresponding Path object.
    """
    dq: deque[tuple[str, Path]] = deque()
    put, get = dq.append, dq.popleft
    put(("", Path(fsdecode(top))))
    while dq:
        dir_, top = dq.popleft()
        try:
            path_iterable = top.iterdir()
        except OSError as e:
            if callable(on_error):
                on_error(e)
            elif on_error:
                raise
            continue
        for path in path_iterable:
            if path.is_symlink() and not follow_symlinks or filter and not filter(path):
                continue
            href = dir_ + "/" + path.name if dir_ else path.name
            if path.is_dir():
                put((href, path))
            else:
                yield href, path


def pack(
    source_dir: bytes | str | PathLike, 
    save_path: None | bytes | str | PathLike = None, 
    generate_id: None | Callable[..., str] = None, 
    init_opf: None | Callable[[], bytes] | bytes | str = None, 
    spine_files: None | Sequence | Container | Callable = None, 
    filter: Optional[Callable[[Path], bool]] = lambda path: (
        path.name not in (".DS_Store", "Thumbs.db") and
        not path.name.startswith("._")
    ), 
    follow_symlinks: bool = True, 
    sort: Optional[Callable] = None, 
    finalize: Optional[Callable] = None, 
    compress: bool = False, 
) -> bytes | str | PathLike:
    """This function is used to pack a directory of files into an ePub format e-book. 

    :param source_dir: The source directory containing the files to be packaged.
    :param save_path: The path where the ePub file will be saved. If not provided, it will be 
                      saved in the same directory as the source with the .epub extension.
    :param generate_id: A function to generate unique identifiers for items in the ePub file.
    :param init_opf: An optional parameter to get the initialized content.opf file of the ePub.
    :param spine_files: An optional parameter to determine which (HTML or XHTML) files of the ePub 
                        should be included in the spine. 
    :param filter: An optional function used to filter the files to be included in the ePub.
    :param follow_symlinks: A boolean indicating whether to follow symbolic links.
    :param sort: An optional function to sort the files before packaging.
    :param finalize: An optional function to perform a finalization step at end of packaging.
    :param compress: Determine whether to perform deflation compression.

    :return: The path where the ePub file is saved.

    Note:
        - The spine_files parameter serves as a predicate to determine which files should be included 
          in the linear reading order (spine) of the ePub. 
        - The spine_files is a sequence, container, or callable, it is used to specify the inclusion 
          criteria for files in the spine.
        - If spine_files is a sequence, it also determines the order of the spine.
    """
    source_dir = ospath.abspath(fsdecode(source_dir))
    if not save_path:
        save_path = source_dir + ".epub"
    if ospath.lexists(save_path):
        remove(save_path)
    spine_map: dict = {}
    if isinstance(spine_files, Sequence):
        # NOTE: If spine_files is a sequence and immutable, then the spine will 
        #       consist of at most the items in this sequence.
        for href in spine_files:
            if href not in spine_map:
                spine_map[href] = None
        if isinstance(spine_files, MutableSequence):
            is_spine = lambda href: href.endswith((".htm", ".html", ".xhtm", ".xhtml"))
    elif isinstance(spine_files, Container):
        is_spine = lambda href: href in spine_files # type: ignore
    elif callable(spine_files):
        is_spine = spine_files
    else:
        is_spine = None
    it = oebps_iter(source_dir, filter=filter, follow_symlinks=follow_symlinks)
    if sort:
        it = sort(it)
    book = ePub(save_path, generate_id=generate_id, init_opf=init_opf)
    for href, path in it:
        item = book.change(href, path)
        if href.endswith((".htm", ".html")):
            content = item.read()
            etree = document_fromstring(content)
            content_new = to_xhtml(etree, ensure_epub=True)()
            if content != content_new:
                item.write(content_new)
        if href in spine_map and spine_map[href] is None or is_spine and is_spine(href):
            spine_map[href] = item
    for item in spine_map.values():
        if item is not None:
            book.spine.add(item)
    if finalize:
        finalize(book)
    if compress:
        book.pack(compression=ZIP_DEFLATED)
    else:
         book.pack()
    return save_path


def pack_sphinx(
    source_dir: bytes | str | PathLike, 
    save_path: None | bytes | str | PathLike = None, 
    follow_symlinks: bool = True, 
    sort: Optional[Callable] = None, 
    compress: bool = False, 
) -> bytes | str | PathLike:
    """Pack a Sphinx documentation into ePub format.

    NOTE: If there are references to online resources, please localize them in advance.

    :param source_dir: Path to the source directory.
    :param save_path: Path where the ePub file will be saved. If not provided, it will be 
                      saved in the same directory as the source with the .epub extension.
    :param follow_symlinks: A boolean indicating whether to follow symbolic links.
    :param sort: An optional function to sort the files before packaging.
    :param compress: Determine whether to perform deflation compression.

    :return: Path to the saved ePub file.
    """
    def clean_toc(el):
        tag = el.tag.lower()
        if tag == "ul":
            el.tag = "ol"
        if tag == "a":
            href = el.attrib.get("href", "")
            el.attrib.clear()
            el.attrib["href"] = href
        else:
            el.attrib.clear()
        for sel in el:
            if sel.tag.lower() in ("ul", "li", "a", "ol"):
                clean_toc(sel)
            else:
                el.remove(sel)
        return el
    def finalize(book):
        # set title
        el = index_etree.head.find('title')
        if el is not None:
            book.title = index_etree.head.find('title').text
        # set cover
        item = book.cover
        if item is None:
            el = index_etree.get_element_by_id("cover")
            if el is not None:
                if "src" in el.attrib:
                    src = el.attrib["src"]
                else:
                    src = el.find(".//*[@src]").attrib["src"]
                item = book.manifest(src)
            else:
                for item in book.image_iter():
                    if item.stem == "cover":
                        if item.get("properties"):
                            item["properties"] += " cover-image"
                        else:
                            item["properties"] = "cover-image"
                        break
            if item is not None:
                book.metadata.name_meta("cover", item["id"], auto_add=True)
        elif "cover-image" in item.get("properties", "").split():
            book.metadata.name_meta("cover", item["id"], auto_add=True)
        else:
            if item.get("properties"):
                item["properties"] += " cover-image"
            else:
                item["properties"] = "cover-image"
        # add nav.xhtml
        if "nav.html" in book.href_to_id:
            etree = document_fromstring(book.read("nav.html"))
            toc_org = etree.get_element_by_id("toc")
            if toc_org is None or len(toc_org) == 0:
                toc = None
            else:
                toc = clean_toc(toc_org[0])
            nav = document_fromstring(bytes(make_nav_xhtml(), "utf-8"))
            if toc is not None:
                toc_tgt = nav.get_element_by_id("toc")
                toc_tgt.append(toc)
            item = book.manifest.change(
                "nav.xhtml", 
                BytesIO(tostring(nav, encoding="utf-8", xml_declaration=True)), 
                attrib={"properties": "nav"}, 
            )
            book.spine.add(item)
    source_dir = ospath.abspath(fsdecode(source_dir))
    if not save_path:
        save_path = source_dir + ".epub"
    if "index.html" in listdir(source_dir):
        index_html_path = ospath.join(source_dir, "index.html")
    else:
        index_html_path = ospath.join(source_dir, 
            next(iglob("**/index.html", root_dir=source_dir, recursive=True)))
        source_dir = ospath.dirname(index_html_path)
    index_etree = document_fromstring(open(index_html_path, "rb").read())
    spine_files = ["index.html", "nav.html"]
    seen = set(spine_files)
    for el in index_etree.cssselect('li[class^="toctree-l"] > a[href]'):
        href: str = el.attrib["href"] # type: ignore
        urlp = urlsplit(href)
        if urlp.scheme or urlp.netloc:
            continue
        href = urlp.path
        if href in seen:
            continue
        spine_files.append(href)
        seen.add(href)
    pack(
        source_dir, 
        save_path, 
        generate_id=posixpath.basename, 
        spine_files=spine_files, 
        filter=lambda path: path.name != "Thumbs.db" and 
                            not path.name.startswith(".") and 
                            not path.name.endswith((".js.map", ".css.map")), 
        follow_symlinks=follow_symlinks, 
        sort=sort, 
        finalize=finalize, 
        compress=compress, 
    )
    return save_path


if __name__ == "__main__":
    print(pack_sphinx(
        args.source_directory, 
        args.save_path, 
        follow_symlinks=not args.not_follow_symlinks, 
        compress=args.compress, 
    ))

